
==================== FINAL INTERFACE ====================
2017-06-01 00:21:12.603288366 UTC

interface main@main:AI.Regression 8002
  interface hash: b3ae16a16a99fcb831eb7845fc34414e
  ABI hash: b76a6b20c80b6a48d7c58eedd89d7f27
  export-list hash: e47537f46f7f385a072c5a95b9bd6042
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: ec690718e88d13d1d9806d316bc0e878
  sig of: Nothing
  used TH splices: False
  where
exports:
  AI.Regression.basefit
  AI.Regression.fgauss
  AI.Regression.gauss
  AI.Regression.mean
  AI.Regression.rgauss
  AI.Regression.split
  AI.Regression.split'
  AI.Regression.std
  AI.Regression.stdAndMean
  AI.Regression.toFunc
  AI.Regression.unfoldTree
  AI.Regression.Regres{AI.Regression.:+ AI.Regression.Const AI.Regression.FGauss}
  AI.Regression.Tree{AI.Regression.End AI.Regression.Node}
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Float 33e2b9ffe427edd6a5c2fd6a3b26703c
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Read b6821365d2d5fa2155c9e910160e7f57
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:Text.ParserCombinators.ReadPrec 5a182a8d6deb0f7d67aed5fab08a5cc0
import  -/  base-4.9.1.0:Text.Read.Lex 16199fac3c6c2d64cc7c268f3c0d2269
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
0e6ba52fc3b68b0987e1e649705938c6
  $fReadRegres ::
    (GHC.Read.Read b, GHC.Read.Read a) =>
    GHC.Read.Read (AI.Regression.Regres a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dRead :: GHC.Read.Read b)
                      ($dRead1 :: GHC.Read.Read a).
                  @ (AI.Regression.Regres a b)
                  (AI.Regression.$fReadRegres_$creadsPrec @ a @ b $dRead $dRead1)
                  (AI.Regression.$fReadRegres_$creadList @ a @ b $dRead $dRead1)
                  (AI.Regression.$fReadRegres_$creadPrec @ a @ b $dRead $dRead1)
                  (AI.Regression.$fReadRegres_$creadListPrec
                     @ a
                     @ b
                     $dRead
                     $dRead1) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fReadRegres1 ::
    (GHC.Read.Read b, GHC.Read.Read a) =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b1.
       ([AI.Regression.Regres a b] -> Text.ParserCombinators.ReadP.P b1)
       -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 4, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dRead :: GHC.Read.Read b)
                   ($dRead1 :: GHC.Read.Read a)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b1
                   (eta1 :: [AI.Regression.Regres a b]
                            -> Text.ParserCombinators.ReadP.P b1) ->
                 GHC.Read.list1
                   @ (AI.Regression.Regres a b)
                   (AI.Regression.$fReadRegres2 @ a @ b $dRead $dRead1)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <AI.Regression.Regres a b>_R))
                   eta
                   @ b1
                   eta1) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fReadRegres2 ::
    (GHC.Read.Read b, GHC.Read.Read a) =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP (AI.Regression.Regres a b)
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U> -}
0e6ba52fc3b68b0987e1e649705938c6
  $fReadRegres_$creadList ::
    (GHC.Read.Read b, GHC.Read.Read a) =>
    Text.ParserCombinators.ReadP.ReadS [AI.Regression.Regres a b]
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   ($dRead :: GHC.Read.Read b)
                   ($dRead1 :: GHC.Read.Read a) ->
                 Text.ParserCombinators.ReadP.run
                   @ [AI.Regression.Regres a b]
                   (GHC.Read.list1
                      @ (AI.Regression.Regres a b)
                      (AI.Regression.$fReadRegres2 @ a @ b $dRead $dRead1)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                <AI.Regression.Regres a b>_R))
                      GHC.Read.$fRead()5
                      @ [AI.Regression.Regres a b]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [AI.Regression.Regres a b]))) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fReadRegres_$creadListPrec ::
    (GHC.Read.Read b, GHC.Read.Read a) =>
    Text.ParserCombinators.ReadPrec.ReadPrec [AI.Regression.Regres a b]
  {- Arity: 4, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                AI.Regression.$fReadRegres1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Read.Read b>_R
                 ->_R <GHC.Read.Read a>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                         <[AI.Regression.Regres a b]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                    <[AI.Regression.Regres a b]>_R))) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fReadRegres_$creadPrec ::
    (GHC.Read.Read b, GHC.Read.Read a) =>
    Text.ParserCombinators.ReadPrec.ReadPrec (AI.Regression.Regres a b)
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                AI.Regression.$fReadRegres2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Read.Read b>_R
                 ->_R <GHC.Read.Read a>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <AI.Regression.Regres a b>_R)) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fReadRegres_$creadsPrec ::
    (GHC.Read.Read b, GHC.Read.Read a) =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (AI.Regression.Regres a b)
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dRead :: GHC.Read.Read b)
                   ($dRead1 :: GHC.Read.Read a)
                   (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (AI.Regression.Regres a b)
                   ((AI.Regression.$fReadRegres2 @ a @ b $dRead $dRead1 eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <AI.Regression.Regres a b>_R)
                      @ (AI.Regression.Regres a b)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (AI.Regression.Regres a b)))) -}
674b06730afdcd93c08b34276cc5ca91
  $fReadTree ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    GHC.Read.Read (AI.Regression.Tree a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dRead :: GHC.Read.Read a)
                      ($dRead1 :: GHC.Read.Read b).
                  @ (AI.Regression.Tree a b)
                  (AI.Regression.$fReadTree_$creadsPrec @ a @ b $dRead $dRead1)
                  (AI.Regression.$fReadTree_$creadList @ a @ b $dRead $dRead1)
                  (AI.Regression.$fReadTree_$creadPrec @ a @ b $dRead $dRead1)
                  (AI.Regression.$fReadTree_$creadListPrec @ a @ b $dRead $dRead1) -}
674b06730afdcd93c08b34276cc5ca91
  $fReadTree1 ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b1.
       ([AI.Regression.Tree a b] -> Text.ParserCombinators.ReadP.P b1)
       -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 4, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dRead :: GHC.Read.Read a)
                   ($dRead1 :: GHC.Read.Read b)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b1
                   (eta1 :: [AI.Regression.Tree a b]
                            -> Text.ParserCombinators.ReadP.P b1) ->
                 GHC.Read.list1
                   @ (AI.Regression.Tree a b)
                   (AI.Regression.$fReadTree2 @ a @ b $dRead $dRead1)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <AI.Regression.Tree a b>_R))
                   eta
                   @ b1
                   eta1) -}
674b06730afdcd93c08b34276cc5ca91
  $fReadTree2 ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP (AI.Regression.Tree a b)
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U> -}
674b06730afdcd93c08b34276cc5ca91
  $fReadTree_$creadList ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadP.ReadS [AI.Regression.Tree a b]
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   ($dRead :: GHC.Read.Read a)
                   ($dRead1 :: GHC.Read.Read b) ->
                 Text.ParserCombinators.ReadP.run
                   @ [AI.Regression.Tree a b]
                   (GHC.Read.list1
                      @ (AI.Regression.Tree a b)
                      (AI.Regression.$fReadTree2 @ a @ b $dRead $dRead1)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                <AI.Regression.Tree a b>_R))
                      GHC.Read.$fRead()5
                      @ [AI.Regression.Tree a b]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [AI.Regression.Tree a b]))) -}
674b06730afdcd93c08b34276cc5ca91
  $fReadTree_$creadListPrec ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadPrec.ReadPrec [AI.Regression.Tree a b]
  {- Arity: 4, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                AI.Regression.$fReadTree1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Read.Read a>_R
                 ->_R <GHC.Read.Read b>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                         <[AI.Regression.Tree a b]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                    <[AI.Regression.Tree a b]>_R))) -}
674b06730afdcd93c08b34276cc5ca91
  $fReadTree_$creadPrec ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadPrec.ReadPrec (AI.Regression.Tree a b)
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                AI.Regression.$fReadTree2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Read.Read a>_R
                 ->_R <GHC.Read.Read b>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <AI.Regression.Tree a b>_R)) -}
674b06730afdcd93c08b34276cc5ca91
  $fReadTree_$creadsPrec ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (AI.Regression.Tree a b)
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dRead :: GHC.Read.Read a)
                   ($dRead1 :: GHC.Read.Read b)
                   (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (AI.Regression.Tree a b)
                   ((AI.Regression.$fReadTree2 @ a @ b $dRead $dRead1 eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <AI.Regression.Tree a b>_R)
                      @ (AI.Regression.Tree a b)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (AI.Regression.Tree a b)))) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fShowRegres ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Show.Show (AI.Regression.Regres a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dShow :: GHC.Show.Show b)
                      ($dShow1 :: GHC.Show.Show a).
                  @ (AI.Regression.Regres a b)
                  (AI.Regression.$fShowRegres_$cshowsPrec @ a @ b $dShow $dShow1)
                  (AI.Regression.$fShowRegres_$cshow @ a @ b $dShow $dShow1)
                  (AI.Regression.$fShowRegres_$cshowList @ a @ b $dShow $dShow1) -}
f77e7521fb235fb81ed609178b0827da
  $fShowRegres1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fShowRegres_$cshow ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    AI.Regression.Regres a b -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (x :: AI.Regression.Regres a b) ->
                 AI.Regression.$fShowRegres_$cshowsPrec
                   @ a
                   @ b
                   $dShow
                   $dShow1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fShowRegres_$cshowList ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    [AI.Regression.Regres a b] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (eta :: [AI.Regression.Regres a b])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (AI.Regression.Regres a b)
                   (AI.Regression.$fShowRegres_$cshowsPrec
                      @ a
                      @ b
                      $dShow
                      $dShow1
                      AI.Regression.$fShowRegres1)
                   eta
                   eta1) -}
0e6ba52fc3b68b0987e1e649705938c6
  $fShowRegres_$cshowsPrec ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Types.Int -> AI.Regression.Regres a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show b)
                   (w1 :: GHC.Show.Show a)
                   (w2 :: GHC.Types.Int)
                   (w3 :: AI.Regression.Regres a b) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 AI.Regression.$w$cshowsPrec @ a @ b w w1 ww1 w3 }) -}
674b06730afdcd93c08b34276cc5ca91
  $fShowTree ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Show.Show (AI.Regression.Tree a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dShow :: GHC.Show.Show a)
                      ($dShow1 :: GHC.Show.Show b).
                  @ (AI.Regression.Tree a b)
                  (AI.Regression.$fShowTree_$cshowsPrec @ a @ b $dShow $dShow1)
                  (AI.Regression.$fShowTree_$cshow @ a @ b $dShow $dShow1)
                  (AI.Regression.$fShowTree_$cshowList @ a @ b $dShow $dShow1) -}
674b06730afdcd93c08b34276cc5ca91
  $fShowTree_$cshow ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    AI.Regression.Tree a b -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   (x :: AI.Regression.Tree a b) ->
                 AI.Regression.$fShowTree_$cshowsPrec
                   @ a
                   @ b
                   $dShow
                   $dShow1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
674b06730afdcd93c08b34276cc5ca91
  $fShowTree_$cshowList ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    [AI.Regression.Tree a b] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   (eta :: [AI.Regression.Tree a b])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (AI.Regression.Tree a b)
                   (AI.Regression.$fShowTree_$cshowsPrec
                      @ a
                      @ b
                      $dShow
                      $dShow1
                      AI.Regression.$fShowRegres1)
                   eta
                   eta1) -}
674b06730afdcd93c08b34276cc5ca91
  $fShowTree_$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Types.Int -> AI.Regression.Tree a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Types.Int)
                   (w3 :: AI.Regression.Tree a b) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 AI.Regression.$w$cshowsPrec1 @ a @ b w w1 ww1 w3 }) -}
178c253c392cea63e0ebaf3733855c1d
  $tc':+ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9168474164357833345##
                   16829738799931100556##
                   AI.Regression.$trModule
                   AI.Regression.$tc':+1) -}
ff68b0efcb2296b06da138965f2500ab
  $tc':+1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "':+"#) -}
155625468a057b7e793a26879062ab24
  $tc'Const :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1060255011328145431##
                   3613333483387433610##
                   AI.Regression.$trModule
                   AI.Regression.$tc'Const1) -}
35682ce2e540c7f063c84aa711ffd007
  $tc'Const1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Const"#) -}
9e1c4f2fe51eef4ca03abb32dd917beb
  $tc'End :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13067507303183260978##
                   3711719709388908921##
                   AI.Regression.$trModule
                   AI.Regression.$tc'End1) -}
133c88223ce305e8a73742131da6f07c
  $tc'End1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'End"#) -}
eafb9d641d1864468b48f181b9eb7497
  $tc'FGauss :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15535840659582212234##
                   1251699857816232563##
                   AI.Regression.$trModule
                   AI.Regression.$tc'FGauss1) -}
27f2d567577d857d9699a774996dd208
  $tc'FGauss1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FGauss"#) -}
7ab10928a28c5884ecad56774b2a1a12
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12320869281158817013##
                   6372232345112494840##
                   AI.Regression.$trModule
                   AI.Regression.$tc'Node1) -}
47c8a92cfc5e0bcb8d4bdb013f441300
  $tc'Node1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Node"#) -}
4ddabe087f64c1ca605eb8f24d487963
  $tcRegres :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11416371256397492810##
                   15655263315011624593##
                   AI.Regression.$trModule
                   AI.Regression.$tcRegres1) -}
fe5e89bee478c2f6367a495ddb4bdbe1
  $tcRegres1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Regres"#) -}
d0168976968c11bdcc9603e9c6870a91
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16799945546652549470##
                   7780433502189153607##
                   AI.Regression.$trModule
                   AI.Regression.$tcTree1) -}
582ffe7ec39c3ae4e308da6d82ff8973
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tree"#) -}
e16bc4638582a2cf0ea94f8d9a833a39
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   AI.Regression.$trModule2
                   AI.Regression.$trModule1) -}
d32958857acf7ee08a6c52e8538a0201
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AI.Regression"#) -}
11212bb6cfd2fc929def812601dadd06
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
0e6ba52fc3b68b0987e1e649705938c6
  $w$cshowsPrec ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Prim.Int# -> AI.Regression.Regres a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
674b06730afdcd93c08b34276cc5ca91
  $w$cshowsPrec1 ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Prim.Int# -> AI.Regression.Tree a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
945fc7ef74e007dd58d3c3983b025a60
  $wbasefit :: GHC.Float.Floating b1 => [(b1, b)] -> (# b1, b1, b1 #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*U,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ b
                   @ b1
                   (w :: GHC.Float.Floating b1)
                   (w1 :: [(b1, b)]) ->
                 let {
                   $dFractional :: GHC.Real.Fractional b1
                   = GHC.Float.$p1Floating @ b1 w
                 } in
                 let {
                   $dNum :: GHC.Num.Num b1 = GHC.Real.$p1Fractional @ b1 $dFractional
                 } in
                 let {
                   ys :: [b1]
                   = case AI.Regression.basefit2 @ b1 @ b w1 of ww { (#,#) ww1 ww2 ->
                     ww1 }
                 } in
                 let {
                   μ :: b1
                   = GHC.Real./
                       @ b1
                       $dFractional
                       (let {
                          k :: b1 -> b1 -> b1 = GHC.Num.+ @ b1 $dNum
                        } in
                        letrec {
                          go :: [b1] -> b1 -> b1 {- Arity: 2, Strictness: <S,1*U><L,U> -}
                          = \ (ds :: [b1]) (eta :: b1) ->
                            case ds of wild { [] -> eta : y ys1 -> go ys1 (k eta y) }
                        } in
                        go ys (GHC.Num.fromInteger @ b1 $dNum AI.Regression.basefit1))
                       (GHC.Num.fromInteger
                          @ b1
                          $dNum
                          (case GHC.List.$wlenAcc @ b1 ys 0# of ww2 { DEFAULT ->
                           GHC.Integer.Type.smallInteger ww2 }))
                 } in
                 let {
                   σ :: b1
                   = GHC.Float.sqrt
                       @ b1
                       w
                       (let {
                          k :: b1 -> b1 -> b1 = GHC.Num.+ @ b1 $dNum
                        } in
                        letrec {
                          go :: [b1] -> b1 -> b1 {- Arity: 2, Strictness: <S,1*U><L,U> -}
                          = \ (ds :: [b1]) (eta :: b1) ->
                            case ds of wild {
                              [] -> eta
                              : y ys1
                              -> go
                                   ys1
                                   (k eta
                                      (let {
                                         x :: b1 = GHC.Num.- @ b1 $dNum μ y
                                       } in
                                       GHC.Num.* @ b1 $dNum x x)) }
                        } in
                        go ys (GHC.Num.fromInteger @ b1 $dNum AI.Regression.basefit1))
                 } in
                 (# σ, σ, μ #)) -}
3fbd4b153f40f4647fdcb00fd7041a70
  $wstdAndMean :: GHC.Float.Floating t => [t] -> (# t, t #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
     Inline: [0] -}
0e6ba52fc3b68b0987e1e649705938c6
  data Regres a b
    = (AI.Regression.Regres a b) :+ (AI.Regression.Regres a b)
    | FGauss a a b
    | Const b
674b06730afdcd93c08b34276cc5ca91
  data Tree a b
    = Node b (AI.Regression.Tree a b) (AI.Regression.Tree a b) | End a
63398add65d6b1b8b76705d8988b38e9
  basefit ::
    GHC.Float.Floating b1 => [(b1, b)] -> AI.Regression.Regres b1 b1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*U,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ b @ b1 (w :: GHC.Float.Floating b1) (w1 :: [(b1, b)]) ->
                 case AI.Regression.$wbasefit
                        @ b
                        @ b1
                        w
                        w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 AI.Regression.FGauss @ b1 @ b1 ww1 ww2 ww3 }) -}
04e5c5132638c4308fa613447d89b888
  basefit1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
d0df1474713d44ab37d8f1075b725368
  basefit2 :: [(b, b1)] -> (# [b], [b1] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
1bae14ac1c84b0cd329e2c1bed85bb2a
  fgauss :: GHC.Float.Floating a => [a] -> [a] -> a -> [a] -> a
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U><L,1*U><L,U><L,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: [a])
                   (eta1 :: [a])
                   (eta2 :: a)
                   (eta3 :: [a]) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 GHC.Num.*
                   @ a
                   $dNum
                   eta2
                   (GHC.Float.exp
                      @ a
                      $dFloating
                      (GHC.Num.negate
                         @ a
                         $dNum
                         (let {
                            lvl12 :: a = GHC.Num.fromInteger @ a $dNum AI.Regression.fgauss2
                          } in
                          GHC.Num.*
                            @ a
                            $dNum
                            (GHC.Real./
                               @ a
                               $dFractional
                               lvl12
                               (GHC.Num.fromInteger @ a $dNum AI.Regression.fgauss1))
                            (let {
                               k :: a -> a -> a = GHC.Num.+ @ a $dNum
                             } in
                             letrec {
                               go :: [(a, a, a)] -> a -> a
                                 {- Arity: 2, Strictness: <S,1*U><L,U> -}
                               = \ (ds :: [(a, a, a)]) (eta4 :: a) ->
                                 case ds of wild {
                                   [] -> eta4
                                   : y ys
                                   -> go
                                        ys
                                        (k eta4
                                           (case y of wild1 { (,,) σ μ v ->
                                            GHC.Num.*
                                              @ a
                                              $dNum
                                              (GHC.Real./ @ a $dFractional lvl12 σ)
                                              (let {
                                                 x :: a = GHC.Num.- @ a $dNum v μ
                                               } in
                                               GHC.Num.* @ a $dNum x x) })) }
                             } in
                             go
                               (GHC.List.zip3 @ a @ a @ a eta eta1 eta3)
                               (GHC.Num.fromInteger @ a $dNum AI.Regression.basefit1)))))) -}
977e01b9161a9b5366159f64764f4959
  fgauss1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
824b0ea2842fe8773384a76ff28742f5
  fgauss2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
dde6c0066a8d416d1cb3b6bf5917c94c
  gauss :: GHC.Float.Floating a => a -> [a] -> [a] -> a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,1*U,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U><L,1*U> -}
953a6cb4af1920e65465369ca93b8b50
  mean ::
    (Data.Foldable.Foldable t, GHC.Real.Fractional a) => t a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,1*C1(U(U)),A,A,A,1*C1(C1(U)),A)><S(LC(C(S))LL),U(1*U,1*C1(C1(U)),A,A)><L,U>,
     Unfolding: (\ @ (t :: * -> *)
                   @ a
                   ($dFoldable :: Data.Foldable.Foldable t)
                   ($dFractional :: GHC.Real.Fractional a)
                   (eta :: t a) ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 GHC.Real./
                   @ a
                   $dFractional
                   (Data.Foldable.sum @ t $dFoldable @ a $dNum eta)
                   (GHC.Num.fromInteger
                      @ a
                      $dNum
                      (case Data.Foldable.length
                              @ t
                              $dFoldable
                              @ a
                              eta of wild { GHC.Types.I# i ->
                       GHC.Integer.Type.smallInteger i }))) -}
585b9d68a81c274986c9a239d7f67b1a
  rgauss ::
    (GHC.Classes.Ord t, GHC.Float.Floating t, GHC.Num.Num a,
     GHC.Classes.Eq a) =>
    [(t, [t])] -> a -> AI.Regression.Regres [t] t
  {- Arity: 6,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(U,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U(C(C1(U)),A)><S,1*U><L,U> -}
373bf19945191e7f7896cfe966ae7908
  split :: GHC.Classes.Ord t1 => [t1] -> [(t, [t1])] -> [[(t, [t1])]]
  {- Arity: 3,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   @ t1
                   ($dOrd :: GHC.Classes.Ord t1)
                   (p :: [t1])
                   (fvals :: [(t, [t1])]) ->
                 AI.Regression.unfoldTree
                   @ t1
                   @ [(t, [t1])]
                   (AI.Regression.split'
                      @ t
                      @ t1
                      $dOrd
                      p
                      (GHC.Base.build
                         @ (t, [t1], [t1])
                         (\ @ b1
                            (c :: (t, [t1], [t1]) -> b1 -> b1)[OneShot]
                            (n :: b1)[OneShot] ->
                          GHC.Base.foldr
                            @ (t, [t1])
                            @ b1
                            (GHC.Base.mapFB
                               @ (t, [t1], [t1])
                               @ b1
                               @ (t, [t1])
                               c
                               (AI.Regression.split1 @ t @ t1))
                            n
                            fvals)))) -}
98e05f15012d50957a468dbaeb0351b3
  split' ::
    GHC.Classes.Ord b =>
    [b] -> [(t, [b], [b])] -> AI.Regression.Tree [(t, [b])] b
  {- Arity: 3,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: (\ @ t
                   @ b
                   ($dOrd :: GHC.Classes.Ord b)
                   (eta :: [b])
                   (eta1 :: [(t, [b], [b])]) ->
                 letrec {
                   split'5 :: [b]
                              -> [(t, [b], [b])] -> AI.Regression.Tree [(t, [b])] b
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [b]) (fvals :: [(t, [b], [b])]) ->
                     case ds of wild {
                       []
                       -> AI.Regression.End
                            @ [(t, [b])]
                            @ b
                            (GHC.Base.map
                               @ (t, [b], [b])
                               @ (t, [b])
                               (AI.Regression.split'4 @ t @ b)
                               fvals)
                       : p ps
                       -> let {
                            ds1 :: ([(t, [b], [b])], [(t, [b], [b])])
                            = letrec {
                                $wgo :: [(t, [b], [b])] -> (# [(t, [b], [b])], [(t, [b], [b])] #)
                                  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                = \ (w :: [(t, [b], [b])]) ->
                                  case w of wild1 {
                                    []
                                    -> (# GHC.Types.[] @ (t, [b], [b]),
                                          GHC.Types.[] @ (t, [b], [b]) #)
                                    : y ys
                                    -> case y of wild2 { (,,) y1 nxs ds2 ->
                                       case ds2 of wild3 {
                                         []
                                         -> case AI.Regression.split'3
                                            ret_ty (# [(t, [b], [b])], [(t, [b], [b])] #)
                                            of {}
                                         : x xs
                                         -> let {
                                              w2 :: ([(t, [b], [b])], [(t, [b], [b])])
                                              = case $wgo ys of ww { (#,#) ww1 ww2 -> (ww1, ww2) }
                                            } in
                                            case GHC.Classes.<= @ b $dOrd x p of wild4 {
                                              GHC.Types.False
                                              -> (# case w2 of wild5 { (,) ts fs -> ts },
                                                    GHC.Types.:
                                                      @ (t, [b], [b])
                                                      wild2
                                                      (case w2 of wild5 { (,) ts fs -> fs }) #)
                                              GHC.Types.True
                                              -> (# GHC.Types.:
                                                      @ (t, [b], [b])
                                                      wild2
                                                      (case w2 of wild5 { (,) ts fs -> ts }),
                                                    case w2 of wild5 { (,) ts fs -> fs } #) } } } }
                              } in
                              case $wgo fvals of ww { (#,#) ww1 ww2 -> (ww1, ww2) }
                          } in
                          AI.Regression.Node
                            @ [(t, [b])]
                            @ b
                            p
                            (split'5
                               ps
                               (case ds1 of wild1 { (,) lessers' greaters' ->
                                GHC.Base.map
                                  @ (t, [b], [b])
                                  @ (t, [b], [b])
                                  (AI.Regression.split'2 @ t @ b)
                                  lessers' }))
                            (split'5
                               ps
                               (case ds1 of wild1 { (,) lessers' greaters' ->
                                GHC.Base.map
                                  @ (t, [b], [b])
                                  @ (t, [b], [b])
                                  (AI.Regression.split'1 @ t @ b)
                                  greaters' })) }
                 } in
                 split'5 eta eta1) -}
a0c4ebd147e47ad3bcc0c67995243975
  split'1 :: (t, [b], [b]) -> (t, [b], [b])
  {- Arity: 1, Strictness: <S(LLS),1*U(U,U,1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t @ b (w :: (t, [b], [b])) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case ww3 of wild {
                   []
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.PtrRepLifted
                        @ (t, [b], [b])
                        "src/AI/Regression.hs:52:26-56|lambda"#
                   : x xs -> (ww1, GHC.Types.: @ b x ww2, xs) } }) -}
df93f553d0d0e93046655502d1daf8fe
  split'2 :: (t, [b], [b]) -> (t, [b], [b])
  {- Arity: 1, Strictness: <S(LLS),1*U(U,U,1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t @ b (w :: (t, [b], [b])) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case ww3 of wild {
                   []
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.PtrRepLifted
                        @ (t, [b], [b])
                        "src/AI/Regression.hs:51:25-55|lambda"#
                   : x xs -> (ww1, GHC.Types.: @ b x ww2, xs) } }) -}
ba1baf2db1741384bbb53ec8af5b99f0
  split'3 :: GHC.Types.Bool
  {- Strictness: x -}
90540a0222d18792f42e5e3c3ee3eb31
  split'4 :: (t, [b], [b]) -> (t, [b])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ t @ b (ds :: (t, [b], [b])) ->
                 case ds of wild { (,,) v nxs xs -> (v, nxs) }) -}
e09c58fd83010d0f3bb57567f97b23f7
  split1 :: (t, [t1]) -> (t, [t1], [t1])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ t @ t1 (ds :: (t, [t1])) ->
                 case ds of wild { (,) v xs -> (v, GHC.Types.[] @ t1, xs) }) -}
82d2a372173abbdd0f74ea24995ee18d
  std :: GHC.Float.Floating f => f -> [f] -> f
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLC(S)LLLLLLLLLLLLLLLLLL),U(1*U,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U>,
     Unfolding: (\ @ f
                   ($dFloating :: GHC.Float.Floating f)
                   (eta :: f)
                   (eta1 :: [f]) ->
                 GHC.Float.sqrt
                   @ f
                   $dFloating
                   (let {
                      $dFractional :: GHC.Real.Fractional f
                      = GHC.Float.$p1Floating @ f $dFloating
                    } in
                    let {
                      $dNum :: GHC.Num.Num f = GHC.Real.$p1Fractional @ f $dFractional
                    } in
                    let {
                      k :: f -> f -> f = GHC.Num.+ @ f $dNum
                    } in
                    letrec {
                      go :: [f] -> f -> f {- Arity: 2, Strictness: <S,1*U><L,U> -}
                      = \ (ds :: [f]) (eta2 :: f) ->
                        case ds of wild {
                          [] -> eta2
                          : y ys
                          -> go
                               ys
                               (k eta2
                                  (let {
                                     x :: f = GHC.Num.- @ f $dNum eta y
                                   } in
                                   GHC.Num.* @ f $dNum x x)) }
                    } in
                    go eta1 (GHC.Num.fromInteger @ f $dNum AI.Regression.basefit1))) -}
6b5caf00b1cd7dcaf134f46405403698
  stdAndMean :: GHC.Float.Floating t => [t] -> (t, t)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ t (w :: GHC.Float.Floating t) (w1 :: [t]) ->
                 case AI.Regression.$wstdAndMean @ t w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
41b3dce730ebaedc6d721ab57bad3988
  toFunc ::
    GHC.Float.Floating a => AI.Regression.Regres [a] a -> [a] -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: AI.Regression.Regres [a] a)
                   (eta1 :: [a]) ->
                 let {
                   $dNum :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum1 :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dNum
                 } in
                 letrec {
                   toFunc1 :: AI.Regression.Regres [a] a -> [a] -> a
                     {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: AI.Regression.Regres [a] a) (vars :: [a]) ->
                     case ds of wild {
                       AI.Regression.:+ a1 b
                       -> GHC.Num.+ @ a $dNum1 (toFunc1 a1 vars) (toFunc1 b vars)
                       AI.Regression.FGauss sig mu scal
                       -> AI.Regression.fgauss @ a $dFloating sig mu scal vars
                       AI.Regression.Const a1 -> a1 }
                 } in
                 toFunc1 eta eta1) -}
8cd4dcc80bf6e4292b30257463697b3a
  unfoldTree :: AI.Regression.Tree t1 t -> [t1]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
instance [safe] GHC.Read.Read [AI.Regression.Regres]
  = AI.Regression.$fReadRegres
instance [safe] GHC.Read.Read [AI.Regression.Tree]
  = AI.Regression.$fReadTree
instance [safe] GHC.Show.Show [AI.Regression.Regres]
  = AI.Regression.$fShowRegres
instance [safe] GHC.Show.Show [AI.Regression.Tree]
  = AI.Regression.$fShowTree
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

